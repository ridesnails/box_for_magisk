# ===================================================================================
# 工作流名称: 构建与推送
# ===================================================================================
name: "📦 构建并推送模块包"

# ===================================================================================
# 触发条件:
# 1. 手动触发 (workflow_dispatch)
# 2. 当 simple 分支有代码推送时触发，但仅限于特定文件或目录发生变化时
#    - 这涵盖了“upstream有更新”和“sing-box核心有推送更新”两种情况
# ===================================================================================
on:
  # 允许在 GitHub Actions 页面手动触发此工作流
  workflow_dispatch:

  # 当有代码推送到 simple 分支时触发
  push:
    branches:
      - simple
    paths:
      # 只有当以下核心文件或目录发生变化时，才触发工作流
      # 这样可以避免修改 README.md 等非功能性文件时也触发构建
      - 'box/bin/sing-box'      # sing-box 核心二进制文件
      - 'box/sing-box/**'       # sing-box 配置文件目录
      - 'box/scripts/**'        # 自定义脚本目录
      - 'box_service.sh'        # 模块主服务脚本
      - 'customize.sh'          # Magisk 安装脚本
      - 'module.prop'           # 模块信息文件

# ===================================================================================
# 任务 (Jobs)
# ===================================================================================
jobs:
  # 定义一个唯一的任务，负责所有事情
  build-and-release:
    # 任务的显示名称
    name: "🏗️ 构建并发布模块"
    # 运行此任务所需的虚拟机环境
    runs-on: ubuntu-latest
    # 为此任务授予写权限，以便它可以创建 GitHub Release
    permissions:
      contents: write

    # 任务的执行步骤
    steps:
      # -----------------------------------------------------------------------------
      # 步骤 1: 检出代码
      # -----------------------------------------------------------------------------
      - name: "🚚 第一步：准备代码仓库"
        uses: actions/checkout@v4
        with:
          # 拉取所有 git 历史记录，这对于后续获取 commit hash 是必需的
          fetch-depth: 0

      # -----------------------------------------------------------------------------
      # 步骤 2: 准备环境和版本信息
      # -----------------------------------------------------------------------------
      - name: "⚙️ 第二步：生成版本信息"
        id: versioning # 给这个步骤一个ID，方便后续引用它的输出
        run: |
          # 核心优化点：赋予 sing-box 二进制文件执行权限，否则无法运行
          echo "🔑 赋予 sing-box 执行权限..."
          chmod +x box/bin/sing-box

          # 核心优化点：直接执行二进制文件以获取其内部版本号
          echo "ℹ️ 获取 sing-box 核心版本..."
          # 执行 version 命令，并使用 awk 提取版本号字符串 (例如 "1.9.0-beta.5")
          CORE_VERSION=$(./box/bin/sing-box version | awk '{print $3}')
          
          # 获取当前 Git 提交的短哈希值 (前7位)
          echo "ℹ️ 获取 Git Commit Hash..."
          GIT_HASH=$(git rev-parse --short HEAD)

          # 组合成最终的模块版本号，格式为：[核心版本]+[commit哈希]
          FINAL_VERSION="${CORE_VERSION}+${GIT_HASH}"
          echo "✅ 成功生成版本号: ${FINAL_VERSION}"

          # 将版本号和打包文件名设置为环境变量，供后续步骤使用
          echo "VERSION=${FINAL_VERSION}" >> $GITHUB_ENV
          echo "FILE_NAME=Box_for_Magisk-simple-${FINAL_VERSION}.zip" >> $GITHUB_ENV
          
          # 将版本号设置为此步骤的输出，供 release 步骤使用
          echo "TAG=${FINAL_VERSION}" >> $GITHUB_OUTPUT

      # -----------------------------------------------------------------------------
      # 步骤 3: 更新模块信息文件
      # -----------------------------------------------------------------------------
      - name: "📝 第三步：更新 module.prop 文件"
        run: |
          echo "✍️ 将版本号写入 module.prop..."
          # 使用 sed 命令将 module.prop 文件中的 version=xxxx 这一行精确替换为我们新生成的版本号
          sed -i "s/^version=.*/version=${{ env.VERSION }}/" module.prop
          echo "✅ module.prop 更新完毕！"
          cat module.prop # 打印出来检查一下

      # -----------------------------------------------------------------------------
      # 步骤 4: 应用默认配置修改
      # -----------------------------------------------------------------------------
      - name: "⚙️ 第四步：应用默认配置修改"
        run: |
          echo "🔧 开始应用默认配置..."

          # 1. 设置默认网络模式为 enhance（增强模式）
          echo "📡 设置默认网络模式为 enhance..."
          if [ -f "box/settings.ini" ]; then
            sed -i 's/^network_mode=.*/network_mode="enhance"/' box/settings.ini
            echo "✅ 网络模式已设置为 enhance"
          else
            echo "⚠️ 未找到 box/settings.ini 文件"
          fi

          # 2. 设置默认代理核心为 sing-box
          echo "🎯 设置默认代理核心为 sing-box..."
          if [ -f "box/settings.ini" ]; then
            sed -i 's/^bin_name=.*/bin_name="sing-box"/' box/settings.ini
            echo "✅ 代理核心已设置为 sing-box"
          fi

          # 3. 设置默认透明代理规则为黑名单模式
          echo "🚫 设置默认透明代理规则为黑名单模式..."
          if [ -f "box/package.list.cfg" ]; then
            sed -i 's/^mode:.*/mode:blacklist/' box/package.list.cfg
            echo "✅ 透明代理规则已设置为黑名单模式"
          else
            echo "⚠️ 未找到 box/package.list.cfg 文件"
          fi

          # 4. 下载并集成 zashboard UI 替代默认 yacd
          echo "🎨 下载并集成 zashboard UI..."
          ZASHBOARD_URL="https://github.com/Zephyruso/zashboard/archive/refs/heads/gh-pages.zip"
          UI_DIR="box/sing-box/dashboard"

          # 创建 UI 目录
          mkdir -p "$UI_DIR"

          # 下载 zashboard
          echo "📥 正在下载 zashboard..."
          curl -L -o zashboard.zip "$ZASHBOARD_URL"

          # 解压并安装
          if [ -f "zashboard.zip" ]; then
            echo "📂 正在解压 zashboard..."
            unzip -q zashboard.zip

            # 查找解压后的目录
            ZASHBOARD_DIR=$(find . -name "zashboard-gh-pages" -type d | head -1)

            if [ -d "$ZASHBOARD_DIR" ]; then
              echo "📋 正在安装 zashboard 到 $UI_DIR..."
              cp -r "$ZASHBOARD_DIR"/* "$UI_DIR/"
              echo "✅ zashboard UI 安装完成"

              # 清理临时文件
              rm -rf zashboard.zip "$ZASHBOARD_DIR"
            else
              echo "❌ 未找到 zashboard 解压目录"
            fi
          else
            echo "❌ zashboard 下载失败"
          fi

          # 5. 显示配置摘要
          echo ""
          echo "📋 配置摘要："
          echo "  🎯 代理核心: sing-box"
          echo "  📡 网络模式: enhance (增强模式)"
          echo "  🚫 代理规则: blacklist (黑名单模式)"
          echo "  🎨 UI 界面: zashboard"
          echo "✅ 默认配置应用完成！"

      # -----------------------------------------------------------------------------
      # 步骤 5: 代码质量检查 (优化点)
      # -----------------------------------------------------------------------------
      - name: "🧐 第五步：检查脚本语法 (Shellcheck)"
        run: |
          echo "🛡️ 开始检查 Shell 脚本语法..."
          shellcheck box_service.sh customize.sh
          echo "✅ 语法检查通过！"

      # -----------------------------------------------------------------------------
      # 步骤 6: 打包模块文件
      # -----------------------------------------------------------------------------
      - name: "📦 第六步：打包模块为 ZIP 文件"
        run: |
          echo "⚙️ 开始打包..."
          # 使用 zip 命令打包所有文件
          # -r 表示递归打包子目录, -9 表示最高压缩率, -q 表示静默模式
          zip -r9q ${{ env.FILE_NAME }} . -x ".git/*" ".github/*" "README.md"
          echo "✅ 打包完成: ${{ env.FILE_NAME }}"

      # -----------------------------------------------------------------------------
      # 步骤 7: 创建 GitHub Release
      # -----------------------------------------------------------------------------
      - name: "🚀 第七步：创建 GitHub 预发布版本"
        uses: softprops/action-gh-release@v1
        with:
          # 要上传的附件文件，即我们打包好的 zip 包
          files: ${{ env.FILE_NAME }}
          # Release 的标签名，使用我们生成的唯一版本号
          tag_name: ${{ steps.versioning.outputs.TAG }}
          # Release 的标题
          name: "滚动更新 ${{ steps.versioning.outputs.TAG }}"
          # Release 的正文内容，使用 Markdown 格式
          body: |
            自动构建于 `simple` 分支的最新提交。
            - **sing-box 核心版本:** `${{ env.VERSION }}`
            - **构建时间:** `$(date -u)`
            - **提交哈希:** `${{ github.sha }}`
          # 将此 Release 标记为预发布版本，适合滚动更新
          prerelease: true

      # -----------------------------------------------------------------------------
      # 步骤 8: 推送到 Telegram Bot
      # -----------------------------------------------------------------------------
      - name: "📱 第八步：推送到 Telegram Bot"
        if: secrets.BOT_TOKEN != '' && secrets.CHAT_ID != ''
        env:
          BOT_TOKEN: ${{ secrets.BOT_TOKEN }}
          CHAT_ID: ${{ secrets.CHAT_ID }}
          VERSION: ${{ env.VERSION }}
        run: |
          echo "📱 准备推送到 Telegram Bot..."

          # 检查必需的环境变量
          if [ -z "$BOT_TOKEN" ] || [ -z "$CHAT_ID" ]; then
            echo "⚠️ 跳过 Telegram 推送: 未设置 BOT_TOKEN 或 CHAT_ID"
            echo "请在 GitHub Secrets 中设置 BOT_TOKEN 和 CHAT_ID"
            exit 0
          fi

          # 安装 Python 依赖
          pip3 install requests

          # 准备推送信息
          export COMMIT="$(git log --oneline -n 5 --no-decorate | sed 's/^[0-9a-f]* //' | sed 's/^/— /')"

          # 查找生成的模块文件
          MODULE_FILE="${{ env.FILE_NAME }}"

          if [ -f "$MODULE_FILE" ]; then
            echo "📦 找到模块文件: $MODULE_FILE"

            # 创建简化的推送脚本
            cat > telegram_push.py << 'EOF'
          #!/usr/bin/env python3
          import os
          import sys
          import requests

          def send_to_telegram(file_path):
              bot_token = os.environ.get("BOT_TOKEN")
              chat_id = os.environ.get("CHAT_ID")
              version = os.environ.get("VERSION", "unknown")
              commit = os.environ.get("COMMIT", "Manual build")

              # 准备消息
              caption = f"""
          {version}

          {commit}

          🔧 默认配置:
          • 代理核心: sing-box
          • 网络模式: enhance (增强模式)
          • 代理规则: blacklist (黑名单模式)
          • UI 界面: zashboard

          🔗 [GitHub](https://github.com/taamarin/box_for_magisk)
          📦 [Releases](https://github.com/taamarin/box_for_magisk/releases)

          #BoxForRoot #Magisk #KernelSU #APatch #singbox #enhance #zashboard
          """.strip()

              # 发送文件
              url = f"https://api.telegram.org/bot{bot_token}/sendDocument"

              with open(file_path, 'rb') as file:
                  files = {'document': file}
                  data = {
                      'chat_id': chat_id,
                      'caption': caption,
                      'parse_mode': 'Markdown'
                  }

                  response = requests.post(url, files=files, data=data, timeout=60)

                  if response.status_code == 200:
                      result = response.json()
                      if result.get('ok'):
                          print("✅ 文件发送成功!")
                          return True
                      else:
                          print(f"❌ 发送失败: {result.get('description', 'Unknown error')}")
                          return False
                  else:
                      print(f"❌ HTTP 错误 {response.status_code}: {response.text}")
                      return False

          if __name__ == "__main__":
              if len(sys.argv) < 2:
                  print("❌ 请提供文件路径")
                  sys.exit(1)

              file_path = sys.argv[1]
              if not os.path.isfile(file_path):
                  print(f"❌ 文件不存在: {file_path}")
                  sys.exit(1)

              if send_to_telegram(file_path):
                  print("🎉 Telegram 推送完成!")
              else:
                  print("❌ Telegram 推送失败!")
                  sys.exit(1)
          EOF

            # 执行推送
            python3 telegram_push.py "$MODULE_FILE"
            echo "✅ Telegram 推送完成"
          else
            echo "❌ 未找到模块文件: $MODULE_FILE"
            exit 1
          fi